import{e as g,f as y,l as x,g as O,i as S}from"./templates-CeJFuBW4.js";import{L as h,M as D,N as P,O as T,P as j,Q as v,R as J}from"./main-C09NvQge.js";import{i as R}from"./utils-DdqsOAFE.js";function F(e){return Object.keys(e?.properties??{}).find(s=>e?.properties[s].format==="bounding-box")}function U(e){return Object.keys(e?.properties??{}).filter(s=>e?.properties[s].type==="geojson")}function I(e,s){const t=U(s);for(const o of t)e[o]&&(R(s?.properties[o])?e[o]=e[o].features.map(r=>JSON.stringify(r.geometry)):e[o]=JSON.stringify(e[o].geometry))}async function B(e,s,t,o,r){let a=null;"eox:flatstyle"in(e??{})&&(a=await g.get(e["eox:flatstyle"]).then(i=>i.data));let n,l;if(a){const i=h(s??"",a);n=i.layerConfig,l=i.style}t=t.sort();const c=t.length>0?{type:"WebGLTile",source:{type:"GeoTIFF",normalize:!l,sources:t.map(i=>({url:i}))},properties:{id:e.id+"_process"+r,title:"Results "+s,...n&&{layerConfig:n},layerControlToolsExpand:!0},...l&&{style:l}}:void 0;return o&&c&&(c.source.projection=o),c}const N=(e,s)=>{if(!s)return;let t=s;if(typeof s=="object"){s=JSON.stringify(s);const r=new Blob([s],{type:"text"});t=URL.createObjectURL(r)}const o=document.createElement("a");confirm(`Would you like to download ${e}?`)&&(o.href=t,o.download=e,o.click()),URL.revokeObjectURL(t),o.remove()};function K(e,s,t){let o="",r="";[o,r]=s??["",""];const[a,n]=e??["",""];try{if(o&&r?(o=new Date(o),r=new Date(r)):(o=new Date(a),r=new Date(n)),(o<new Date(a)||o>new Date(n))&&(console.warn("[eodash] warn: start date is outside of the collection temporal extent and will be clamped",`
provided start date:${o.toISOString()}`,`
collection start date:${a}`),o=new Date(a)),(r>new Date(n)||r<new Date(a))&&(console.warn("[eodash] warn: end date is outside of the collection temporal extent and will be clamped",`
provided end date:${r.toISOString()}`,`
collection end date:${n}`),r=new Date(n)),o>r)return console.error("[eodash] Error: start date is greater than end date",o,r),[]}catch(d){return console.error("[eodash] Invalid date:",d.message),[]}const l=o.toISOString(),c=r.toISOString();if(!l||!c)return[];const i=[];let p=new Date(c);const u=new Date(l),f=1440*60*1e3,b=t==="daily"?f:t==="weekly"?f*7:t==="monthly"?f*30:t==="yearly"?f*365:f;for(;p>=u&&i.length<31;)i.push(new Date(p)),p.setTime(p.getTime()-b);const w=[];for(let d=0;d<i.length-1;d++)w.push([i[d].toISOString(),i[d+1].toISOString()]);return w}function W(e,s,t){if(!e)return[[],[]];const o=[],r=[];for(const a of e){const n=a.rel===s,l=t?a.type===t:!0;n&&l&&(a.endpoint?r.push(a):o.push(a))}return[o,r]}async function _(e,s,t,o=""){const r=[],a=await L(s);for(const n of e){const l=$(n,a);let c,i;if(l){const u=h(t?.id??"",l);i=u.layerConfig,c=u.style}let p=D(t);switch(n.type){case"image/tiff":{r.push({type:"WebGLTile",properties:{id:s.id+"_process"+n.id+o,title:"Results "+(t?.id??"")+" "+(n.id??""),layerControlToolsExpand:!0,...i&&{layerConfig:i},...p},source:{type:"GeoTIFF",normalize:!c,sources:n.urls.map(u=>({url:u})),...t["eodash:mapProjection"]?.name&&{projection:t["eodash:mapProjection"].name}},...c&&{style:c}});break}case"application/geo+json":{const u=await P(n.urls);r.push({type:"Vector",source:{type:"Vector",format:"GeoJSON",...u&&{url:u}},properties:{id:s.id+"_process_"+n.id+o,title:"Results "+(t?.id??"")+" "+(n.id??""),...i&&{layerConfig:{...i,style:c}},...p},...!c?.variables&&{style:c},interactions:[]});break}case"application/vnd.flatgeobuf":{n.urls.forEach((u,f)=>{r.push({type:"Vector",source:{type:"FlatGeoBuf",url:u},properties:{id:s.id+"_process_"+n.id+o+`_${f}`,title:"Results "+(t?.id??"")+" "+(n.id??""),layerControlToolsExpand:!0,...i&&{layerConfig:{...i,style:c}},...p}})});break}default:console.warn(`[eodash] Unsupported result type "${n.type}" for ${n.id} layer creation.`);break}}return r}async function L(e){let s=null;return e["eox:flatstyle"]&&(typeof e["eox:flatstyle"]=="string"?s=await g.get(e["eox:flatstyle"]).then(t=>t.data):Array.isArray(e["eox:flatstyle"])&&e["eox:flatstyle"].length?(s={multipleStyles:!0},await Promise.all(e["eox:flatstyle"].map(async t=>{s[t.id]=await g.get(t.url).then(o=>o.data)}))):(s={multipleStyles:!0},await Promise.all(Object.keys(e["eox:flatstyle"]??{}).map(t=>{s[t]=g.get(e["eox:flatstyle"][t]).then(o=>o.data)})))),s}function $(e,s){if(!s)return;if(!("multipleStyles"in s))return s;const t=e.id;if(!(!t||!(t in s)))return s[t]}function k(e){if(!e)return[];if("urls"in e&&Array.isArray(e.urls))return[{id:"",urls:e.urls,type:"image/tiff"}];const s=[];for(const t in e)t!=="id"&&s.push({id:t,urls:e[t].urls,type:e[t].mimetype});return s}const z=e=>{for(const s in e.properties)if(e.properties[s]?.options?.drawtools)return s},C=(e,s)=>{if(!s.length||!e)return;const o=[...(e.id==="compare"?T:j)()];let r=o.find(a=>a.properties?.id.includes("AnalysisGroup"));if(r){for(const a of s)r.layers.find(l=>l.properties?.id===a.properties?.id)?r.layers=v(r.layers,a.properties?.id??"",[a]):r.layers.unshift(a);if(e){const a=[...o],n=e.id==="compare"?"compareProcess:updated":"process:updated";J(n,e,a),e.layers=a}}};function Q(e){if(!e)return e;const s=JSON.stringify(e).replaceAll("eox-map#main","eox-map#compare");return JSON.parse(s)}async function q({jobs:e,processUrl:s,isPolling:t,pollInterval:o=1e4,maxRetries:r=560,enableCompare:a=!1}){let n=0;for(t.value=!0,setTimeout(()=>{m(e,a?O.value:S.value)},500);n<r&&t.value;){try{const l=new Date().getTime(),i=(await y.get(`${s}?t=${l}`)).data;if(i.status==="successful"){console.log("Process completed successfully. Fetching result item...");const p=i.links[1].href;if(!p)throw new Error("Result links not found in the process report.");const u=await y.get(p);return console.log("Result file fetched successfully:",u.data),u.data}if(i.status==="failed")throw t.value=!1,new Error("Process failed.",i);console.log(`Status: ${i.status}. Retrying in ${o/1e3} seconds...`)}catch(l){l instanceof Error?console.error("Error while polling process status:",l.message):console.error("Unknown error occurred:",l)}await new Promise(l=>setTimeout(l,o)),n++}if(!t.value)return console.warn("Polling was stopped before the process was completed."),JSON.parse("{}");throw new Error("Max retries reached. Process did not complete successfully.")}async function m(e,s){const t=JSON.parse(localStorage.getItem(s)||"[]"),o=await Promise.all(t.map(r=>y.get(r,{params:{t:Date.now()}}).then(a=>a.data)));o.sort((r,a)=>new Date(a.job_start_datetime).getTime()-new Date(r.job_start_datetime).getTime()),e.value=o}const H=async(e,s,t)=>{const r=JSON.parse(localStorage.getItem(t)||"[]").filter(a=>!a.includes(s.jobID));localStorage.setItem(t,JSON.stringify(r)),await m(e,t)},X=async(e,s)=>{const t=[],o=e.links.find(r=>r.rel.includes("results")&&r.type=="application/json");o&&(await y.get(o.href).then(r=>r.data).then(r=>{if(r.urls)t.push(...r.urls);else for(const a of Object.values(r))t.push(...a.urls)}),t.forEach(r=>{if(!r)return;let a="";typeof r=="string"?(a=r.includes("/")?r.split("/").pop()??"":r,a=a.includes("?")?a.split("?")[0]:a):a=s?.id+"_process_results.json",N(a,r)}))},Y=async(e,s,t)=>{const o=await y.get(e.links[1].href).then(r=>r.data);await G({selectedStac:s,results:o,jobId:e.jobID,mapElement:t})};async function G({selectedStac:e,results:s,jobId:t,mapElement:o}){const r=e?.links.find(l=>l.rel==="service"&&l.endpoint=="eoxhub_workspaces");if(!r)return;const a=k(s),n=await _(a,r,e,t);x.debug("rendered layers after loading previous process:",n),C(o,n)}const Z=(e,s)=>JSON.parse(localStorage.getItem(s)||"[]").find(r=>r.includes(e));export{H as a,_ as b,B as c,X as d,k as e,F as f,Z as g,K as h,Q as i,z as j,I as k,Y as l,C as m,N as n,q as p,W as s,m as u};
