import{e3 as h,ed as b,ee as S,ef as D,eg as O,dG as P,e2 as g,eh as d,aA as T,d_ as v,d$ as J}from"./index-BfirqpGG.js";import{g as R}from"./utils-sG5MXUTE.js";function I(e){return Object.keys(e?.properties??{}).find(r=>e?.properties[r].format==="bounding-box")}function j(e){return Object.keys(e?.properties??{}).filter(r=>e?.properties[r].type==="geojson")}function E(e,r){const t=j(r);for(const o of t)e[o]&&(R(r?.properties[o])?e[o]=e[o].features.map(s=>JSON.stringify(s.geometry)):e[o]=JSON.stringify(e[o].geometry))}async function F(e,r,t,o,s){let a=null;"eox:flatstyle"in(e??{})&&(a=await g.get(e["eox:flatstyle"]).then(l=>l.data));let n,i;if(a){const l=h(r??"",a);n=l.layerConfig,i=l.style}t=t.sort();const c=t.length>0?{type:"WebGLTile",source:{type:"GeoTIFF",normalize:!i,sources:t.map(l=>({url:l}))},properties:{id:e.id+"_process"+s,title:"Results "+r,...n&&{layerConfig:n},layerControlToolsExpand:!0},...i&&{style:i}}:void 0;return o&&c&&(c.source.projection=o),c}const $=(e,r)=>{if(!r)return;let t=r;if(typeof r=="object"){r=JSON.stringify(r);const s=new Blob([r],{type:"text"});t=URL.createObjectURL(s)}const o=document.createElement("a");confirm(`Would you like to download ${e}?`)&&(o.href=t,o.download=e,o.click()),URL.revokeObjectURL(t),o.remove()};function M(e,r,t){let o="",s="";[o,s]=r??["",""];const[a,n]=e??["",""];try{if(o&&s?(o=new Date(o),s=new Date(s)):(o=new Date(a),s=new Date(n)),(o<new Date(a)||o>new Date(n))&&(console.warn("[eodash] warn: start date is outside of the collection temporal extent and will be clamped",`
provided start date:${o.toISOString()}`,`
collection start date:${a}`),o=new Date(a)),(s>new Date(n)||s<new Date(a))&&(console.warn("[eodash] warn: end date is outside of the collection temporal extent and will be clamped",`
provided end date:${s.toISOString()}`,`
collection end date:${n}`),s=new Date(n)),o>s)return console.error("[eodash] Error: start date is greater than end date",o,s),[]}catch(f){return console.error("[eodash] Invalid date:",f.message),[]}const i=o.toISOString(),c=s.toISOString();if(!i||!c)return[];const l=[];let u=new Date(c);const y=new Date(i),p=1440*60*1e3,x=t==="daily"?p:t==="weekly"?p*7:t==="monthly"?p*30:t==="yearly"?p*365:p;for(;u>=y&&l.length<31;)l.push(new Date(u)),u.setTime(u.getTime()-x);const w=[];for(let f=0;f<l.length-1;f++)w.push([l[f].toISOString(),l[f+1].toISOString()]);return w}function B(e,r,t){if(!e)return[[],[]];const o=[],s=[];for(const a of e){const n=a.rel===r,i=t?a.type===t:!0;n&&i&&(a.endpoint?s.push(a):o.push(a))}return[o,s]}async function k(e,r,t,o=""){const s=[],a=await N(r);for(const n of e){const i=U(n,a);let c,l;if(i){const u=h(t?.id??"",i);l=u.layerConfig,c=u.style}switch(n.type){case"image/tiff":{s.push({type:"WebGLTile",properties:{id:r.id+"_process"+n.id+o,title:"Results "+(t?.id??"")+" "+(n.id??""),layerControlToolsExpand:!0,...l&&{layerConfig:l}},source:{type:"GeoTIFF",normalize:!c,sources:n.urls.map(u=>({url:u})),...t["eodash:mapProjection"]?.name&&{projection:t["eodash:mapProjection"].name}},...c&&{style:c}});break}case"application/geo+json":{const u=await b(n.urls);s.push({type:"Vector",source:{type:"Vector",format:"GeoJSON",...u&&{url:u}},properties:{id:r.id+"_process_"+n.id+o,title:"Results "+(t?.id??"")+" "+(n.id??""),...l&&{layerConfig:{...l,style:c}}},...!c?.variables&&{style:c},interactions:[]});break}default:console.warn(`[eodash] Unsupported result type "${n.type}" for ${n.id} layer creation.`);break}}return s}async function N(e){let r=null;return e["eox:flatstyle"]&&(typeof e["eox:flatstyle"]=="string"?r=await g.get(e["eox:flatstyle"]).then(t=>t.data):Array.isArray(e["eox:flatstyle"])&&e["eox:flatstyle"].length?(r={multipleStyles:!0},await Promise.all(e["eox:flatstyle"].map(async t=>{r[t.id]=await g.get(t.url).then(o=>o.data)}))):(r={multipleStyles:!0},await Promise.all(Object.keys(e["eox:flatstyle"]??{}).map(t=>{r[t]=g.get(e["eox:flatstyle"][t]).then(o=>o.data)})))),r}function U(e,r){if(!r)return;if(!("multipleStyles"in r))return r;const t=e.id;if(!(!t||!(t in r)))return r[t]}function _(e){if(!e)return[];if("urls"in e&&Array.isArray(e.urls))return[{id:"",urls:e.urls,type:"image/tiff"}];const r=[];for(const t in e)t!=="id"&&r.push({id:t,urls:e[t].urls,type:e[t].mimetype});return r}const G=(e,r)=>{if(!r.length||!e)return;const o=[...(e.id==="compare"?S:D)()];let s=o.find(a=>a.properties?.id.includes("AnalysisGroup"));if(s){for(const a of r)s.layers.find(i=>i.properties?.id===a.properties?.id)?s.layers=O(s.layers,a.properties?.id??"",[a]):s.layers.unshift(a);if(e){const a=[...o],n=e.id==="compare"?"compareProcess:updated":"process:updated";P(n,e,a),e.layers=a}}};function K(e){if(!e)return e;const r=JSON.stringify(e).replaceAll("eox-map#main","eox-map#compare");return JSON.parse(r)}async function W({jobs:e,processUrl:r,isPolling:t,pollInterval:o=1e4,maxRetries:s=560,enableCompare:a=!1}){let n=0;for(t.value=!0,setTimeout(()=>{m(e,a?v.value:J.value)},500);n<s&&t.value;){try{const i=new Date().getTime(),l=(await d.get(`${r}?t=${i}`)).data;if(l.status==="successful"){console.log("Process completed successfully. Fetching result item...");const u=l.links[1].href;if(!u)throw new Error("Result links not found in the process report.");const y=await d.get(u);return console.log("Result file fetched successfully:",y.data),y.data}if(l.status==="failed")throw t.value=!1,new Error("Process failed.",l);console.log(`Status: ${l.status}. Retrying in ${o/1e3} seconds...`)}catch(i){i instanceof Error?console.error("Error while polling process status:",i.message):console.error("Unknown error occurred:",i)}await new Promise(i=>setTimeout(i,o)),n++}if(!t.value)return console.warn("Polling was stopped before the process was completed."),JSON.parse("{}");throw new Error("Max retries reached. Process did not complete successfully.")}async function m(e,r){const t=JSON.parse(localStorage.getItem(r)||"[]"),o=await Promise.all(t.map(s=>d.get(s,{params:{t:Date.now()}}).then(a=>a.data)));o.sort((s,a)=>new Date(a.job_start_datetime).getTime()-new Date(s.job_start_datetime).getTime()),e.value=o}const z=async(e,r,t)=>{const s=JSON.parse(localStorage.getItem(t)||"[]").filter(a=>!a.includes(r.jobID));localStorage.setItem(t,JSON.stringify(s)),await m(e,t)},q=async(e,r)=>{const t=[],o=e.links.find(s=>s.rel.includes("results")&&s.type=="application/json");o&&(await d.get(o.href).then(s=>s.data).then(s=>{t.push(...s.urls)}),t.forEach(s=>{if(!s)return;let a="";typeof s=="string"?(a=s.includes("/")?s.split("/").pop()??"":s,a=a.includes("?")?a.split("?")[0]:a):a=r?.id+"_process_results.json",$(a,s)}))},H=async(e,r,t)=>{const o=await d.get(e.links[1].href).then(s=>s.data);await L({selectedStac:r,results:o,jobId:e.jobID,mapElement:t})};async function L({selectedStac:e,results:r,jobId:t,mapElement:o}){const s=e?.links.find(i=>i.rel==="service"&&i.endpoint=="eoxhub_workspaces");if(!s)return;const a=_(r),n=await k(a,s,e,t);T.debug("rendered layers after loading previous process:",n),G(o,n)}export{k as a,M as b,F as c,$ as d,_ as e,K as f,I as g,E as h,G as i,q as j,z as k,H as l,W as p,B as s,m as u};
