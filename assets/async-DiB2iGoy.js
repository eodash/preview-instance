import{br as S,bs as v,r as O,bD as y,bq as p,ay as x,bx as k,aN as w}from"./index-sM6GxOqw.js";import{g as L}from"./utils-sG5MXUTE.js";function E(s){return Object.keys(s?.properties??{}).find(o=>s?.properties[o].format==="bounding-box")}function T(s){return Object.keys(s?.properties??{}).filter(o=>s?.properties[o].type==="geojson")}function $(s,o){const r=T(o);for(const e of r)s[e]&&(L(o?.properties[e])?s[e]=s[e].features.map(t=>JSON.stringify(t.geometry)):s[e]=JSON.stringify(s[e].geometry))}async function j(s,o,r,e,t){let a=null;"eox:flatstyle"in(s??{})&&(a=await S.get(s["eox:flatstyle"]).then(l=>l.data));let i,n;if(a){const l=v(o??"",a);i=l.layerConfig,n=l.style}r=r.sort();const c=r.length>0?{type:"WebGLTile",source:{type:"GeoTIFF",normalize:!n,sources:r.map(l=>({url:l}))},properties:{id:s.id+"_process"+t,title:"Results "+o,...i&&{layerConfig:i},layerControlToolsExpand:!0},...n&&{style:n}}:void 0;return e&&c&&(c.source.projection=e),c}const P=(s,o)=>{if(!o)return;let r=o;if(typeof o=="object"){o=JSON.stringify(o);const t=new Blob([o],{type:"text"});r=URL.createObjectURL(t)}const e=document.createElement("a");confirm(`Would you like to download ${s}?`)&&(e.href=r,e.download=s,e.click()),URL.revokeObjectURL(r),e.remove()};function N(s,o,r){let e="",t="";[e,t]=o??["",""];const[a,i]=s??["",""];try{if(e&&t?(e=new Date(e),t=new Date(t)):(e=new Date(a),t=new Date(i)),(e<new Date(a)||e>new Date(i))&&(console.warn("[eodash] warn: start date is outside of the collection temporal extent and will be clamped",`
provided start date:${e.toISOString()}`,`
collection start date:${a}`),e=new Date(a)),(t>new Date(i)||t<new Date(a))&&(console.warn("[eodash] warn: end date is outside of the collection temporal extent and will be clamped",`
provided end date:${t.toISOString()}`,`
collection end date:${i}`),t=new Date(i)),e>t)return console.error("[eodash] Error: start date is greater than end date",e,t),[]}catch(f){return console.error("[eodash] Invalid date:",f.message),[]}const n=e.toISOString(),c=t.toISOString();if(!n||!c)return[];const l=[];let d=new Date(c);const b=new Date(n),u=24*60*60*1e3,D=r==="daily"?u:r==="weekly"?u*7:r==="monthly"?u*30:r==="yearly"?u*365:u;for(;d>=b&&l.length<31;)l.push(new Date(d)),d.setTime(d.getTime()-D);const g=[];for(let f=0;f<l.length-1;f++)g.push([l[f].toISOString(),l[f+1].toISOString()]);return g}function U(s,o,r){if(!s)return[[],[]];const e=[],t=[];for(const a of s){const i=a.rel===o,n=r?a.type===r:!0;i&&n&&(a.endpoint?t.push(a):e.push(a))}return[e,t]}const h=O([]);async function G({processUrl:s,isPolling:o,pollInterval:r=1e4,maxRetries:e=560}){let t=0;for(o.value=!0,setTimeout(()=>{m(h,p)},500);t<e&&o.value;){try{const a=new Date().getTime(),n=(await y.get(`${s}?t=${a}`)).data;if(n.status==="successful"){console.log("Process completed successfully. Fetching result item...");const c=n.links[1].href;if(!c)throw new Error("Result links not found in the process report.");const l=await y.get(c);return console.log("Result file fetched successfully:",l.data),l.data}if(n.status==="failed")throw o.value=!1,new Error("Process failed.",n);console.log(`Status: ${n.status}. Retrying in ${r/1e3} seconds...`)}catch(a){a instanceof Error?console.error("Error while polling process status:",a.message):console.error("Unknown error occurred:",a)}await new Promise(a=>setTimeout(a,r)),t++}if(!o.value)return console.warn("Polling was stopped before the process was completed."),JSON.parse("{}");throw new Error("Max retries reached. Process did not complete successfully.")}async function m(s,o){const r=JSON.parse(localStorage.getItem(o.value)||"[]"),e=await Promise.all(r.map(t=>fetch(t).then(a=>a.json())));e.sort((t,a)=>new Date(a.job_start_datetime).getTime()-new Date(t.job_start_datetime).getTime()),s.value=e}const _=async s=>{const r=JSON.parse(localStorage.getItem(p.value)||"[]").filter(e=>!e.includes(s.jobID));localStorage.setItem(p.value,JSON.stringify(r)),m(h,p)},C=async(s,o)=>{const r=[];await fetch(s.links[1].href).then(e=>e.json()).then(e=>{r.push(...e.urls)}),r.forEach(e=>{if(!e)return;let t="";typeof e=="string"?(t=e.includes("/")?e.split("/").pop()??"":e,t=t.includes("?")?t.split("?")[0]:t):t=o?.id+"_process_results.json",P(t,e)})},F=async(s,o)=>{const r=[];await y.get(s.links[1].href).then(e=>r.push(e.data)),await I({selectedStac:o,results:r,jobId:s.jobID})};async function I({selectedStac:s,results:o,jobId:r}){const e=s?.links.filter(a=>a.rel==="service"&&a.type==="image/tiff"),t=await j(e?.[0],s?.id??"",o?.[0].urls,s?.["eodash:mapProjection"]?.name??null,r);if(x.debug("rendered layers after loading previous process:",t),t){const a=[...t?[t]:[]];let i=[...k()];i.find(c=>c.properties?.id.includes("AnalysisGroup"))?.layers.push(...a),w.value&&(w.value.layers=[...i])}}export{N as a,C as b,j as c,P as d,$ as e,_ as f,E as g,h as j,F as l,G as p,U as s,m as u};
