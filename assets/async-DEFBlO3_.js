import{e5 as h,ef as x,eg as S,eh as O,ei as D,ej as j,dG as P,e4 as g,ek as y,aA as T,dN as v,dM as J}from"./index-COBZVAZ0.js";import{g as R}from"./utils-sG5MXUTE.js";function M(e){return Object.keys(e?.properties??{}).find(r=>e?.properties[r].format==="bounding-box")}function U(e){return Object.keys(e?.properties??{}).filter(r=>e?.properties[r].type==="geojson")}function F(e,r){const t=U(r);for(const o of t)e[o]&&(R(r?.properties[o])?e[o]=e[o].features.map(s=>JSON.stringify(s.geometry)):e[o]=JSON.stringify(e[o].geometry))}async function I(e,r,t,o,s){let a=null;"eox:flatstyle"in(e??{})&&(a=await g.get(e["eox:flatstyle"]).then(i=>i.data));let n,l;if(a){const i=h(r??"",a);n=i.layerConfig,l=i.style}t=t.sort();const c=t.length>0?{type:"WebGLTile",source:{type:"GeoTIFF",normalize:!l,sources:t.map(i=>({url:i}))},properties:{id:e.id+"_process"+s,title:"Results "+r,...n&&{layerConfig:n},layerControlToolsExpand:!0},...l&&{style:l}}:void 0;return o&&c&&(c.source.projection=o),c}const N=(e,r)=>{if(!r)return;let t=r;if(typeof r=="object"){r=JSON.stringify(r);const s=new Blob([r],{type:"text"});t=URL.createObjectURL(s)}const o=document.createElement("a");confirm(`Would you like to download ${e}?`)&&(o.href=t,o.download=e,o.click()),URL.revokeObjectURL(t),o.remove()};function B(e,r,t){let o="",s="";[o,s]=r??["",""];const[a,n]=e??["",""];try{if(o&&s?(o=new Date(o),s=new Date(s)):(o=new Date(a),s=new Date(n)),(o<new Date(a)||o>new Date(n))&&(console.warn("[eodash] warn: start date is outside of the collection temporal extent and will be clamped",`
provided start date:${o.toISOString()}`,`
collection start date:${a}`),o=new Date(a)),(s>new Date(n)||s<new Date(a))&&(console.warn("[eodash] warn: end date is outside of the collection temporal extent and will be clamped",`
provided end date:${s.toISOString()}`,`
collection end date:${n}`),s=new Date(n)),o>s)return console.error("[eodash] Error: start date is greater than end date",o,s),[]}catch(d){return console.error("[eodash] Invalid date:",d.message),[]}const l=o.toISOString(),c=s.toISOString();if(!l||!c)return[];const i=[];let f=new Date(c);const u=new Date(l),p=1440*60*1e3,b=t==="daily"?p:t==="weekly"?p*7:t==="monthly"?p*30:t==="yearly"?p*365:p;for(;f>=u&&i.length<31;)i.push(new Date(f)),f.setTime(f.getTime()-b);const w=[];for(let d=0;d<i.length-1;d++)w.push([i[d].toISOString(),i[d+1].toISOString()]);return w}function K(e,r,t){if(!e)return[[],[]];const o=[],s=[];for(const a of e){const n=a.rel===r,l=t?a.type===t:!0;n&&l&&(a.endpoint?s.push(a):o.push(a))}return[o,s]}async function _(e,r,t,o=""){const s=[],a=await k(r);for(const n of e){const l=$(n,a);let c,i;if(l){const u=h(t?.id??"",l);i=u.layerConfig,c=u.style}let f=x(t);switch(n.type){case"image/tiff":{s.push({type:"WebGLTile",properties:{id:r.id+"_process"+n.id+o,title:"Results "+(t?.id??"")+" "+(n.id??""),layerControlToolsExpand:!0,...i&&{layerConfig:i},...f},source:{type:"GeoTIFF",normalize:!c,sources:n.urls.map(u=>({url:u})),...t["eodash:mapProjection"]?.name&&{projection:t["eodash:mapProjection"].name}},...c&&{style:c}});break}case"application/geo+json":{const u=await S(n.urls);s.push({type:"Vector",source:{type:"Vector",format:"GeoJSON",...u&&{url:u}},properties:{id:r.id+"_process_"+n.id+o,title:"Results "+(t?.id??"")+" "+(n.id??""),...i&&{layerConfig:{...i,style:c}},...f},...!c?.variables&&{style:c},interactions:[]});break}case"application/vnd.flatgeobuf":{n.urls.forEach((u,p)=>{s.push({type:"Vector",source:{type:"FlatGeoBuf",url:u},properties:{id:r.id+"_process_"+n.id+o+`_${p}`,title:"Results "+(t?.id??"")+" "+(n.id??""),layerControlToolsExpand:!0,...i&&{layerConfig:{...i,style:c}},...f}})});break}default:console.warn(`[eodash] Unsupported result type "${n.type}" for ${n.id} layer creation.`);break}}return s}async function k(e){let r=null;return e["eox:flatstyle"]&&(typeof e["eox:flatstyle"]=="string"?r=await g.get(e["eox:flatstyle"]).then(t=>t.data):Array.isArray(e["eox:flatstyle"])&&e["eox:flatstyle"].length?(r={multipleStyles:!0},await Promise.all(e["eox:flatstyle"].map(async t=>{r[t.id]=await g.get(t.url).then(o=>o.data)}))):(r={multipleStyles:!0},await Promise.all(Object.keys(e["eox:flatstyle"]??{}).map(t=>{r[t]=g.get(e["eox:flatstyle"][t]).then(o=>o.data)})))),r}function $(e,r){if(!r)return;if(!("multipleStyles"in r))return r;const t=e.id;if(!(!t||!(t in r)))return r[t]}function C(e){if(!e)return[];if("urls"in e&&Array.isArray(e.urls))return[{id:"",urls:e.urls,type:"image/tiff"}];const r=[];for(const t in e)t!=="id"&&r.push({id:t,urls:e[t].urls,type:e[t].mimetype});return r}const G=(e,r)=>{if(!r.length||!e)return;const o=[...(e.id==="compare"?O:D)()];let s=o.find(a=>a.properties?.id.includes("AnalysisGroup"));if(s){for(const a of r)s.layers.find(l=>l.properties?.id===a.properties?.id)?s.layers=j(s.layers,a.properties?.id??"",[a]):s.layers.unshift(a);if(e){const a=[...o],n=e.id==="compare"?"compareProcess:updated":"process:updated";P(n,e,a),e.layers=a}}};function W(e){if(!e)return e;const r=JSON.stringify(e).replaceAll("eox-map#main","eox-map#compare");return JSON.parse(r)}async function z({jobs:e,processUrl:r,isPolling:t,pollInterval:o=1e4,maxRetries:s=560,enableCompare:a=!1}){let n=0;for(t.value=!0,setTimeout(()=>{m(e,a?v.value:J.value)},500);n<s&&t.value;){try{const l=new Date().getTime(),i=(await y.get(`${r}?t=${l}`)).data;if(i.status==="successful"){console.log("Process completed successfully. Fetching result item...");const f=i.links[1].href;if(!f)throw new Error("Result links not found in the process report.");const u=await y.get(f);return console.log("Result file fetched successfully:",u.data),u.data}if(i.status==="failed")throw t.value=!1,new Error("Process failed.",i);console.log(`Status: ${i.status}. Retrying in ${o/1e3} seconds...`)}catch(l){l instanceof Error?console.error("Error while polling process status:",l.message):console.error("Unknown error occurred:",l)}await new Promise(l=>setTimeout(l,o)),n++}if(!t.value)return console.warn("Polling was stopped before the process was completed."),JSON.parse("{}");throw new Error("Max retries reached. Process did not complete successfully.")}async function m(e,r){const t=JSON.parse(localStorage.getItem(r)||"[]"),o=await Promise.all(t.map(s=>y.get(s,{params:{t:Date.now()}}).then(a=>a.data)));o.sort((s,a)=>new Date(a.job_start_datetime).getTime()-new Date(s.job_start_datetime).getTime()),e.value=o}const q=async(e,r,t)=>{const s=JSON.parse(localStorage.getItem(t)||"[]").filter(a=>!a.includes(r.jobID));localStorage.setItem(t,JSON.stringify(s)),await m(e,t)},H=async(e,r)=>{const t=[],o=e.links.find(s=>s.rel.includes("results")&&s.type=="application/json");o&&(await y.get(o.href).then(s=>s.data).then(s=>{if(s.urls)t.push(...s.urls);else for(const a of Object.values(s))t.push(...a.urls)}),t.forEach(s=>{if(!s)return;let a="";typeof s=="string"?(a=s.includes("/")?s.split("/").pop()??"":s,a=a.includes("?")?a.split("?")[0]:a):a=r?.id+"_process_results.json",N(a,s)}))},Q=async(e,r,t)=>{const o=await y.get(e.links[1].href).then(s=>s.data);await L({selectedStac:r,results:o,jobId:e.jobID,mapElement:t})};async function L({selectedStac:e,results:r,jobId:t,mapElement:o}){const s=e?.links.find(l=>l.rel==="service"&&l.endpoint=="eoxhub_workspaces");if(!s)return;const a=C(r),n=await _(a,s,e,t);T.debug("rendered layers after loading previous process:",n),G(o,n)}const X=(e,r)=>JSON.parse(localStorage.getItem(r)||"[]").find(s=>s.includes(e));export{_ as a,B as b,I as c,N as d,C as e,W as f,M as g,F as h,G as i,X as j,H as k,Q as l,q as m,z as p,K as s,m as u};
